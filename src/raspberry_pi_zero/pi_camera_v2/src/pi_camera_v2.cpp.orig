#include <memory>
#include <opencv2/core/core.hpp>
#include <opencv2/core/types.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/opencv.hpp>
#include <opencv2/videoio.hpp>
#include <rclcpp/node.hpp>
#include <std_msgs/msg/detail/header__struct.hpp>

#include "cv_bridge/cv_bridge.h"
#include "image_transport/camera_publisher.hpp"
#include "image_transport/image_transport.hpp"
#include "image_transport/publisher.hpp"
#include "rclcpp/rclcpp.hpp"

int main(int argc, char* argv[]) {
    rclcpp::init(argc, argv);
<<<<<<< HEAD
    rclcpp::Node::SharedPtr cam_node = rclcpp::Node::make_shared("pi_camera");

    /*****************************************************************************************/

    cv::Mat frame;
    printf("Opening camera...\n");
    cv::VideoCapture capture(0);  // open the first camera
    if (!capture.isOpened()) {
        printf("ERROR: Can't initialize camera capture");
        return 1;
    }

    /* int width = capture.get(cv::CAP_PROP_FRAME_WIDTH); */
    /* int height = capture.get(cv::CAP_PROP_FRAME_HEIGHT); */
    printf("Frame width: %f \n", capture.get(cv::CAP_PROP_FRAME_WIDTH));
    printf("     height: %f \n", capture.get(cv::CAP_PROP_FRAME_HEIGHT));
    printf("Capturing FPS: %f \n", capture.get(cv::CAP_PROP_FPS));

    size_t nFrames = 0;
    /* bool enableProcessing = false; */
    int64 t0 = cv::getTickCount();
    int64 processingTime = 0;

    int count = 0;
    while (count < 100) {
        capture >> frame;  // read the next frame from camera
        if (frame.empty()) {
            printf("ERROR: Can't grab camera frame.");
            break;
        }
        nFrames++;
        if (nFrames % 10 == 0) {
            const int N = 10;
            int64 t1 = cv::getTickCount();
            std::cout << "Frames captured: "
                      << cv::format("%5lld", (long long int)nFrames)
                      << "    Average FPS: "
                      << cv::format("%9.1f", (double)cv::getTickFrequency() *
                                                 N / (t1 - t0))
                      << "    Average time per frame: "
                      << cv::format("%9.2f ms",
                                    (double)(t1 - t0) * 1000.0f /
                                        (N * cv::getTickFrequency()))
                      << "    Average processing time: "
                      << cv::format("%9.2f ms",
                                    (double)(processingTime)*1000.0f /
                                        (N * cv::getTickFrequency()))
                      << std::endl;
            t0 = t1;
            processingTime = 0;
        }
        int64 tp0 = cv::getTickCount();
        sensor_msgs::msg::Image::Ptr image_out =
            cv_bridge::CvImage(std_msgs::msg::Header(), "brg8", frame)
                .toImageMsg();
=======
    auto cam_node = rclcpp::Node::make_shared("pi_camera");
    time_now = cam_node->get_clock();

    image_transport::ImageTransport it(cam_node);
    auto publisher = it.advertise("image", 1);

    int width = 1920;
    int height = 1080;
    int fmt_index = 2;

    // open camera file
    fd = open(DEVICE, O_RDWR);
    if (fd < 0) {
        perror(DEVICE);
        return -1;
    }

    cam_node->get_parameter_or("width", width, 1920);
    cam_node->get_parameter_or("height", height, 1080);
    cam_node->get_parameter_or("fmt_index", fmt_index, 2);

    if (0 != print_caps()) {
        printf("ERROR: print_caps");
        close(fd);
        return -1;
    }
    print_available_formats();

    if (0 != init_device(fmt_index, width, height)) {
        printf("ERROR: init device");
        close(fd);
        return -1;
    }

    if (0 != init_mmap()) {
        printf("ERROR: init mmap");
        return -1;
    }

    if (-1 == start_capturing()) {
        printf("ERROR: starting stream");
        cleanup();
        close(fd);
        return -1;
    }

    fd_set fds;
    struct timeval tv;
    int r;
    int count = 0;
    while (count < 100) {
        // Clear the set of file descriptors to monitor, then add the fd
        // for our device
        FD_ZERO(&fds);
        FD_SET(fd, &fds);

        // Set the timeout
        tv.tv_sec = 2;
        tv.tv_usec = 0;

        r = select(fd + 1, &fds, NULL, NULL, &tv);

        if (-1 == r && errno == EINTR) {
            continue;
        } else if (r == -1) {
            return -1;
        } else if (r == 0) {
            fprintf(stderr, "select timeout\n");
            return -1;
        } else {
            if (-1 == read_frame(&publisher, width, height)) {
                return -1;
            }
        }
        count++;
    }
>>>>>>> 17bbce8a3356733e49373d42cee787eba04e8853

        processingTime += cv::getTickCount() - tp0;
        count++;
    }
    std::cout << "Number of captured frames: " << nFrames << std::endl;
    /*****************************************************************************************/
    rclcpp::shutdown();

    return 0;
}
